
networks: # Terminada de definir os servi칞os que ser칚o iniciados nesse docker-compose, usamos essa diretiva para definir quais redes usaremos nesse arquivo docker-compose.yml
  my_network: # Definimos a cria칞칚o de uma rede "my_network".
    driver: bridge  # E "settamos" o drive de rede que ela usar치.

volumes:
  grafana-storage:
  loki-data:


services: # Diretiva que indica que sob essa sess칚o definiremos containers.



  spring-app: # Definimos o nome do servi칞o.
    build: # Definimos que a nossa Imagem ser치 obtida por meio de um "build". E dentro dessa diretiva definimos como ser치 feito o "build".
      context: .. # Usamos essa diretiva para informar o path de onde ser치 feito o "build" da nossa Imagem.
      dockerfile: Dockerfile # Especificamos qual arquivo ser치 utilizado para fazer o "build" da Imagem.
    image: myapp  # Como faremos o "build" de uma Imagem, definimos o seu nome.
    ports: # Fazemos o mapeamento que todo solicita칞칚o feita a porta 8080 do host para a porta 8080 do container.
      - "8080:8080"
    container_name: spring-app # "Settamos" o nome do container ao ser executado.
#    restart: always # Definimos a sua pol칤tica de reinicializa칞칚o em casos de falha ou parada.
    #volumes:
    #  - ../logs:/app/logs
    depends_on: # Usamos essa diretiva para dizer que h치 uma depend칡ncia entre servi칞o.
      postgres_db: # Com o nome / chave do servi칞o, nos explicitamos que h치 uma depend칡ncia entre o servi칞o atual e o mysql_db.
        condition: service_healthy # Settamos a condi칞칚o que o torna dependente do container mysql_db, para service_healthy.
    environment: # Explicitamos que queremos passar vari치veis de ambiente para a Imagem desse container. E as definimos.
      SPRING_DATASOURCE_URL: ${SPRING_DATASOURCE_URL}
      SPRING_DATASOURCE_USERNAME: ${POSTGRES_USER}
      SPRING_DATASOURCE_PASSWORD: ${POSTGRES_PASSWORD}
      SPRING_DATASOURCE_DRIVER: ${SPRING_DATASOURCE_DRIVER}
      HIBERNATE_DIALECT: ${HIBERNATE_DIALECT}
    #env_file: # Como n칚o iremos usar a "file" autom치ticamente identificada pelo Docker (.env) usamos essa diretiva que nos permite explicitar de onde obteremos essa nova "file".
    #  - ./env/.env  # Definimos a "file" que obteremos no ligar do padr칚o.
    networks: # Associamos esse container com uma rede/s especifica.
      - my_network


  prometheus:
    image: prom/prometheus:latest
    container_name: prometheus
    #    network_mode: "host"  # 游녣 ADICIONE ESTA LINHA
    ports:
      - "127.0.0.1:9090:9090" # Expondo o Prometheus no host
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--web.external-url=http://localhost:9090'
    volumes:
      - ./prometheus/prometheus.yml:/etc/prometheus/prometheus.yml
      - ./prometheus/alerting-rules.yml:/etc/prometheus/alerting-rules.yml
    networks:
      - my_network



  postgres_db: # Definimos o nome do servi칞o. Ou se preferir a chave do container.
    image: postgres:17.4-alpine3.21 # Definimos a Imagem sob a qual esse container ser치 executado.
    ports:  # Diretiva tem fun칞칚o de expor e mapear portas entre host e containers.
      - "127.0.0.1:5432:5432" # Definimos que portas ser칚o mapeadas entre o host e o container.
    container_name: postgres_db  # Definimos o nome do container para que a ele n칚o seja atribu칤do um default.
    restart: always # Definimos a pol칤tica de reinicializa칞칚o autom치tica do container diante de paradas ou falhas.
    environment:  # Definimos as vari치veis de ambiente essenciais para configura칞칚o inicial do Banco de dados.
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_DB: ${POSTGRES_DB}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
    #env_file: # Como n칚o iremos usar a "file" autom치ticamente identificada pelo Docker (.env) usamos essa diretiva que nos permite explicitar de onde obteremos essa nova "file".
    #  - ./env/.env  # Definimos a "file" que obteremos no ligar do padr칚o.
    #command: --skip-name-resolve  # Utilizamos essa diretiva que nos permite comandos personalizados a respeito inicializa칞칚o do container.
    networks: # Usamos essa diretiva para associar esse container a uma rede Docker.
      - my_network  # Explicitamos a qual rede/s esse container ser치 associado.
    healthcheck: # Definimos uma verifica칞칚o peri칩dica sobre a sa칰de do container, a qual ocorrer치 mediante tais testes...
      test: [ "CMD-SHELL", "pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB}" ]
      interval: 10s # Tempo entre cada Verifica칞칚o
      timeout: 5s # Tempo limite para execu칞칚o do test antes de ser considerado falha.
      retries: 5  # N칰mero limite de falhas aceitas antes do container ser considerado unhealthy.


  postgres_exporter:
    image: bitnami/postgres-exporter
    container_name: postgres_exporter
    ports:
      - "127.0.0.1:9187:9187"
    environment:
      DATA_SOURCE_NAME: ${DATA_SOURCE_NAME}
    depends_on:
      - postgres_db
    networks:
      - my_network


  alertmanager:
    image: prom/alertmanager
    container_name: alertmanager
    ports:
      - "127.0.0.1:9093:9093"
    volumes:
      - ./alertmanager/config.yml:/etc/alertmanager/config.yml
    command:
      - '--config.file=/etc/alertmanager/config.yml'
      - '--web.external-url=http://localhost:9093'
    networks:
      - my_network

  mailpit:
    image: axllent/mailpit
    container_name: mailpit
    ports:
      - "127.0.0.1:1025:1025"
      - "127.0.0.1:8025:8025"
    #volumes:
    #  - /data
    networks:
      - my_network


  alloy:
    image: grafana/alloy:latest
    container_name: alloy
    volumes:
      - /var/lib/docker/containers:/var/lib/docker/containers:ro # Monta o diret칩rio onde os logs dos containers vivem no host e ":ro" = somente leitura. Fazendo com que os logs sejam lidos direto dos containers Docker.
      - ./alloy/config.alloy:/etc/alloy/config.alloy
    ports:
      - "127.0.0.1:4320:4320"
      - "127.0.0.1:4444:4444"
    networks:
      - my_network


#  # Promtail (envia os logs para o Loki)
#  promtail:
#    image: grafana/promtail:latest
#    container_name: promtail
#    volumes:
#      - /var/lib/docker/containers:/var/lib/docker/containers:ro # Monta o diret칩rio onde os logs dos containers vivem no host e ":ro" = somente leitura. Fazendo com que os logs sejam lidos direto dos containers Docker.
#      - ./promtail/promtail-config.yaml:/etc/promtail/promtail-config.yaml  # Mapeia seu arquivo de configura칞칚o local para o container.
#      #- /var/run/docker.sock:/var/run/docker.sock # Permite que o Promtail se conecte ao daemon Docker. Para associar logs aos nomes dos containers (labels, nomes, etc).
#    command: -config.file=/etc/promtail/promtail-config.yaml
#    depends_on:
#      - loki
#    networks:
#      - my_network



  loki:
    image: grafana/loki:latest
    container_name: loki
    command: -config.file=/etc/loki/local-config.yaml
    ports:
      - "127.0.0.1:3100:3100"
    volumes:
      - ./loki/loki-config.yaml:/etc/loki/loki-config.yaml
      - loki-data:/loki
    networks:
      - my_network


#  collector:
#    image: otel/opentelemetry-collector-contrib:0.97.0
#    container_name: collector
#    volumes:
#      - ./collector/otel-collector.yaml:/etc/otelcol/config.yaml
#    command: [ "--config=/etc/otelcol/config.yaml" ]
#    ports:
#      - "127.0.0.1:4317:4317"   # OTLP gRPC
#      - "127.0.0.1:4318:4318"   # OTLP HTTP
#      - "127.0.0.1:8888:8888"   # Metrics/debug
#    depends_on:
#      - tempo
#    networks:
#      - my_network


  tempo:
    image: grafana/tempo:2.4.1
    container_name: tempo
    command: [ "-config.file=/etc/tempo.yaml" ]
    volumes:
      - ./tempo/tempo.yaml:/etc/tempo.yaml
    ports:
      - "127.0.0.1:3200:3200"     # tempo http UI
    networks:
      - my_network


  grafana:
    image: grafana/grafana:latest
    container_name: grafana
    ports:
      - "127.0.0.1:3000:3000" # Grafana vai rodar na porta 3000
    environment:
      - GF_SECURITY_ADMIN_USER=${GF_SECURITY_ADMIN_USER}
      - GF_SECURITY_ADMIN_PASSWORD=${GF_SECURITY_ADMIN_PASSWORD}
      - GF_AUTH_ANONYMOUS_ENABLED=${GF_AUTH_ANONYMOUS_ENABLED}
    networks:
      - my_network
    volumes:
      - grafana-storage:/var/lib/grafana
    depends_on:
      - loki


  ui-angular_app:
    build: ../../armchair-management-ui
    image: ui-app
    ports:
      - "4200:80"
    container_name: ui-angular_app
    restart: always
    depends_on:
      spring-app:
        condition: service_healthy



